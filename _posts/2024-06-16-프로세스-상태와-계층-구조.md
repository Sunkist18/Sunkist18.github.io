---
title: "프로세스 상태와 계층 구조"
date: 2024-06-16 02:50:00 +0900
categories: ['Study-Log', 'OS - 혼자 공부하는 운영체제']
tags: ['부모 프로세스', '자식 프로세스', '프로세스 계층 구조', '프로세스 상태']
image: assets/img/20240616/1.png
description: PCB를 자세히 다뤄봅니다.
---


운영체제는 컴퓨터 시스템에서 여러 프로세스를 효율적으로 관리합니다.

프로세스는 실행 중인 프로그램을 의미하며, 각 프로세스는 다양한 상태를 가지며 계층적인 구조를 형성합니다.

이번 포스팅에서는 프로세스의 상태와 계층 구조에 대해 알아보겠습니다.  
  

## 프로세스 상태

프로세스는 실행되는 동안 다양한 상태를 거칩니다.

운영체제는 프로세스의 상태를 **프로세스 제어 블록(PCB, Process Control Block)**을 통해 관리합니다.

주요 프로세스 상태는 다음과 같습니다:

1.  **생성 상태 (new)**: 프로세스가 메모리에 적재되어 PCB를 할당받는 상태.
2.  **준비 상태 (ready)**: CPU를 할당받기 위해 대기 중인 상태.  
    준비 상태에서 실행 상태로 전환되는 것을 **디스패치(dispatch)**라고 합니다.
3.  **실행 상태 (running)**: CPU를 할당받아 실행 중인 상태.  
    할당된 시간을 모두 사용하면 다시 준비 상태로 돌아가거나, 입출력 작업을 위해 대기 상태로 전환됩니다.
4.  **대기 상태 (blocked)**: 입출력 작업 등의 특정 이벤트를 기다리는 상태.  
    입출력 작업이 완료되면 다시 준비 상태로 돌아갑니다.
5.  **종료 상태 (terminated)**: 프로세스가 종료된 상태로, 운영체제가 PCB와 사용된 메모리를 정리합니다.

> 의문: 종료 상태가 되면 PCB가 제거되는데, 제거된다 함은 종료 상태임을 알 수 없는 것 아닌가?  
>   종료 상태가 된 프로세스는 좀비 상태로 존재하게 됩니다.  
>   이는 부모 프로세스가 자원을 회수할 때까지 메모리에 남아 있게 하여 추적할 수 있도록 합니다.  
>   부모 프로세스가 자원을 회수하면 그때 PCB가 완전히 제거됩니다.

### 프로세스 상태 다이어그램

프로세스의 상태 전환을 시각적으로 나타낸 **프로세스 상태 다이어그램**은 다음과 같습니다:

![](assets/img/20240616/1.png) 

## 프로세스 계층 구조

프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있습니다.  
부모 프로세스는 자식 프로세스를 생성하며, 이들 프로세스는 계층적인 구조를 형성합니다.  
예를 들어, 최초의 프로세스는 시스템 부팅 시 생성되며, 자식 프로세스들을 생성하여 트리 구조를 형성합니다.

-   **부모 프로세스 (parent process)**: 다른 프로세스를 생성한 프로세스.
-   **자식 프로세스 (child process)**: 부모 프로세스에 의해 생성된 프로세스. 각기 다른 PID를 가집니다.

### 프로세스 계층 구조 예시

사용자가 컴퓨터를 켜고 로그인한 후, bash 셸을 통해 Vim 편집기를 실행하는 과정을 예로 들면 다음과 같습니다:

1.  최초 프로세스가 로그인 프로세스를 생성.
2.  로그인 프로세스가 사용자 인터페이스 프로세스를 생성.
3.  사용자 인터페이스 프로세스가 Vim 프로세스를 생성.

> 의문: unix init, linux systemd, macOS launchd의 d는 무엇을 의미하나?  
>   'd'는 daemon의 약자로, 시스템에서 백그라운드에서 실행되는 프로세스를 의미합니다.

## 프로세스 생성 기법

운영체제는 **fork**와 **exec** 시스템 호출을 통해 프로세스를 생성하고 실행합니다:

-   **fork**: 부모 프로세스의 복사본을 자식 프로세스로 생성.
-   **exec**: 자식 프로세스의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출.

> 의문: fork-exec 형식을 굳이 해야 하나? '복사'되는 과정에서 오버헤드가 있지는 않을까?  
>   현대 운영체제는 copy on write 기술을 통해 오버헤드를 줄입니다.  
>   실제로 메모리를 복사하지 않고, 부모 프로세스의 메모리를 공유하다가 변경(쓰기)이 일어날 때만 실제로 메모리 복사를 진행합니다.

### 예시

bash 셸에서 `ls` 명령어를 실행할 때, 셸 프로세스는 fork를 통해 자신과 동일한 프로세스를 생성하고,  
자식 프로세스는 exec를 통해 `ls` 명령어를 실행합니다.

## 결론

운영체제는 프로세스를 다양한 상태로 관리하고, 계층적인 구조로 프로세스를 생성합니다.  
이를 통해 시스템 자원을 효율적으로 활용하고 안정적인 프로그램 실행을 보장합니다.

---

### 확인 문제

1.  최초 프로세스가 로그인 프로세스를 생성하고, 로그인 프로세스는 bash 프로세스를,  
    bash 프로세스는 Vim 프로세스를 생성했다고 가정해 보겠습니다.
    -   bash 프로세스의 부모 프로세스는 무엇인가요?
    -   bash 프로세스의 자식 프로세스는 무엇인가요?
    -   Vim 프로세스의 부모 프로세스는 무엇인가요?
2.  **fork**와 **exec**에 대한 설명으로 **옳지 않은** 것을 고르세요.
    -   fork 시스템 호출을 하면 새로운 폴더가 생성됩니다.
    -   fork 시스템 호출을 하면 부모 프로세스의 복제본이 자식 프로세스로서 생성됩니다.
    -   exec 시스템 호출을 하면 프로세스의 메모리 공간이 다른 프로세스의 내용으로 변경됩니다.
    -   많은 운영체제는 fork와 exec을 통해 프로세스 계층 구조를 형성합니다.
3.  **프로세스 상태**에 대한 설명으로 **옳은** 것을 고르세요.
    -   **생성 상태**는 프로세스가 입출력 장치의 작업을 기다리는 상태입니다.
    -   **실행 상태**는 프로세스가 종료되는 상태입니다.
    -   **종료 상태**는 프로세스가 이제 막 생성된 상태입니다.
    -   **준비 상태**는 CPU를 할당받기를 기다리고 있는 상태입니다.
